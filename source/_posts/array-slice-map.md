---
title: 快速理解Go的复合数据类型（数组、切片、映射）
date: 2019-03-27 23:00:00
categories:
- 技术
tags:
- 复合数组类型
- go
- 2019
---

在go语言里，复合数据类型分别是：数组、切片、映射。为了快速掌握这三种数据类型使用方式，而写了这篇笔记。

#### 数组

##### 声明方式

一维数组的申明有三种方式，如下：

```
1. 指定数组长度、初始化各元素的值
arr := [5]int{1,2,3,4,5}

2. 不指定数组的长度，由具体初始化的元素个数决定长度
arr := [...]int{0,1,2,3,4}

3. 指定数组长度，初始化指定索引的元素的值，其余元素为0
arr := [5]int{1:10,2:20}
```

<!-- more -->

二维数组的申明，有以下几种：

```
1. 指定数组长度
var array [4][2]int

2. 指定数组长度，初始化各元素的值
array := [4][2]int{{10,11}, {20,21}, {30,31}, {40,41}}

3. 指定外层数组中索引为1和3的元素
array := [4][2]int{1:{20,21}, 3: {40,41}}

4. 指定外层数组和内层数组中的单个元素
array := [4][2]int{1: {0: 20}, 3: {1: 41}}
```

##### 读取与修改方式

读取与修改的方式，同其它语言是一样，都是使用 变量名[索引] 的方式。

一维数组：
```
array := [5]int{1:10,2:20}
fmt.Printf("值为：%d", array[2])
array[2] = 22
fmt.Printf("值为：%d", array[2])
```

二维数组：
```
array := [4][2]int{1: {0: 20}, 3: {1: 41}}
fmt.Printf("值为：%d", array[3][1])
array[3][1] = 88
fmt.Printf("值为：%d", array[3][1])
```

##### 数组传递给函数

**一定要以数组指针的方式传递。** 如果是以传值得方式传递，系统开销比较大、性能差；函数在调用时，数组会复制一份作为函数的参数。

> 例如：一个包含100万个int类型元素的数组；在64位架构上，需要800万字节（即8M的内存），这种量级别的大小，传递时是一个非常重的操作。如果换成传数组的指针，则需要8字节的空间。

#### 切片

##### 创建切片

创建数组切面有两种方式：一种是内置函数make()、另一种是切片字面量。个人感觉这两种差不多，只是写法不一样而已。

内置函数make()
```
// 创建切片，长度和容量都是5个元素
slice := make([]int, 5)

// 创建切片，长度是3个元素、容量是5个元素
slice := make([]int, 3, 5)
```

切片字面量
```
// 创建切片，长度和容量都是5个元素，同时赋值
slice := []string{"apple", "banana", "strawberry", "orange", "watermelon"}

// 创建切片，使用空字符串初始化第100个元素
slice := []string{99:""}

// 创建多维切片
slice := [][]int{{10}, {100,200}}
```

> 注：切片的长度不能大于容量。

##### 切片的赋值与分割

切片赋值

```
// 一维切片赋值
// 改变索引为1的元素的值
slice := []int{10,20,30,40,50}
slice[1] = 25

// 多维切片赋值
slice := [][]int{{10}, {100,200}}
// 为第一个切片的追加值为20的元素
slice[0] = append(slice[0], 20)
```

切片分割

```
// 创建切片
slice := []int{10,20,30,40,50}

// 分割一个新切片。长度为2个元素，容量为4个元素。计算规则：长度=3-1、容量=5-1
newSlice := slice[1:3]

// 分割一个新切片。长度为1个元素，容量为2个元素。计算规则：长度=3-2、容量=4-2
newSlice := slice[2:3:4]
```

> 注：分割后的两个切片，共享的是容一个底层数组。说白了，就是其中一个切片修改底层数组元素的值，另一个切片也会受到影响。

##### 扩容切片

个人感觉切片扩容，才是切片核心特性，因为它可以动态的增加数据集合的容量；否则数组完全能代替切片。

动态扩容实例，如下：
```
slice := []int{10,20,30,40,50}

// 分割一个新切片
newSlice := slice[1:3]
fmt.Println(len(newSlice), cap(newSlice))

// 进行新元素赋值，容量够用
newSlice = append(newSlice, 60, 70)
fmt.Println(len(newSlice), cap(newSlice))

// 再次，进行新元素赋值，容量已超
newSlice = append(newSlice, 80)
fmt.Println(len(newSlice), cap(newSlice))

输出结果：
2 4
4 4
5 8
```

> 注：
> * 如果切片底层数组的容量够用，append()会将追加的元素，合并到切片的底层数组中。
> * 如果切片底层数组的容量不够用，append()会创建一个新的底层数组，同时会将现有的底层数组复制到新的数组，再追加新的值。**另外，切片的容量小于1000个元素时，会成倍的增加容量；当超过1000个元素时，每次会增加25%的容量。**

##### 遍历切片

切片是一个集合，所以必须要通过关键字for来遍历获取里面的元素。

```
slice := []int{10,20,30,40,50}
for index, value := range slice {
    fmt.Printf("索引：%d，值为：%d\n", index, value)
}
```

##### 限制容量

切片的容量限制，其实为了控制新切片的容量，同时也为切片的底层数组的提供保护，可以更好的控制追加。

具体代码例子：
```
source := []string{"apple", "banana", "strawberry", "orange", "watermelon"}
slice := source[2:3:3]
fmt.Println(len(slice), cap(slice))

slice = append(slice, "mango")
fmt.Println(len(slice), cap(slice))

for index, value := range slice {
    fmt.Printf("索引：%d，值为：%s\n", index, value)
}

输出结果：
1 1
2 2
索引：0，值为：strawberry
索引：1，值为：mango
```

根据上面的例子可以看出：限制了新切片的容量，同时新切片追加的新元素时，也不会影响其它切片底层数组的元素。

##### 切片传递给函数

**以传值的方式传递切片。** 由于数据与切片自身是两部分，而数据是在底层数组中，不属于切片本身；所以在传递切片时，对底层数据没有影响；复制的也只是切片本身，况且切片本身数据量也很小。

> 在64位架构的机器上，一个切片需要24B的内存：指针字段需要8B，长度和容量字段分别需要8B。

#### 映射

映射是一个数据集合，它与数组的区别在于：数组是有序的，而映射是无序的。

##### 映射创建

创建映射有两种方式：一种是内置函数make()、另一种是映射字面量

```
// 内置make()函数
dict := make(map[string]int)

// 映射字面量
dict := map[string]string{"red":"#da1337", "black":"#000"}
```

##### 映射元素的赋值

映射的赋值很简单，如下：

```
// 创建一个空映射
colors := map[string]string{}

// 写入映射中，red为key
colors["red"] = "#da1337"
```

##### 映射元素的查找

从映射中取值，有三种方式

1. 通过指定的Key来获取值，前提要判断Key是否存在

```
colors := map[string]string{}
colors["red"] = "#da1337"
colors["black"] = "#000"
value, exist := colors["red"]
if exist {
    fmt.Println(value)
}
```

2. 通过返回对应Key的值，前提要判断值是否为空、且存储的值不是非零值的情况下

```
value := colors["red"]
if value != "" {
    fmt.Println(value)
}
```

3. 利用关键字for，循环取值

```
colors := map[string]string{}
colors["red"] = "#da1337"
colors["black"] = "#000"
for index, value := range colors {
    fmt.Printf("Key：%s，值为：%s\n", index, value)
}
```

##### 映射元素的删除

删除元素比较简单，通过内置函数delete()，即可删除指定的元素。

```
colors := map[string]string{}
colors["red"] = "#da1337"
delete(colors, "red")
```