---
title: 关于进程方面的个人理解
date: 2018-03-31 19:42:48
tags:
- 进程
- 技术
---

在Unix及其衍生的操作系统中（包含Linux），每个程序都是在进程中执行的，所以每个程序的执行叫做**进程**。

在这些系统中，每个进程都有父进程，而最顶级是**内核启动进程**，可以理解为进程的鼻祖（而它的父进程就是它自己）。当某个程序的父进程在子进程之前挂掉，那么这些子进程将会被内核启动进程“收养”，成为它的“嫡系儿子”。

> 内核启动进程：主要是负责系统的初始化工作。

**创建子进程** 通过系统调用系统的fork函数，就可以创建一个子进程。
举例说吧：当进程A创建了进程B（我个人比较粗俗的理解为：复制了一份进程A，只不过它叫进程B），这时，进程B就是A的子进程，因此B就会获得A的数据段、堆、栈以及代码段。

<!-- more -->

**进程描述符**  它存在的价值主要是便于内核的管理，每个进程都会有一个描述符。**进程描述符是一个数据结构**，数据结构中包含：进程的ID（PID）、父进程的ID（PPID）、优先级、状态、虚拟地址范围、各种访问权限等信息。

**进程ID（PID）的生成规则**，其实就是根据前一个进程ID进行递增；当ID值达到上限（也就是最大值）时，内核会从闲置的进程ID中，查找最小的ID来使用。

**进程的状态** 主要分为以下几种：
- `可运行状态：`正在CPU上执行或立刻要执行进程。
- `可中断的睡眠状态：`正在等待某个事件（如：网络连接、信号量）到来；处于这种状态的进程，会被放入事件的等待队列，当事件发生时，会被唤醒。
- `不可中断的睡眠状态：`此状态与上一个的区别就是 - 不可打断；也就是说，当发送给此状态进程的信号，要等该进程的状态扭转后，才会作出响应。
- `暂停状态或跟踪状态：`向进程发送SIGSTOP信号，进程就会扭转至`暂停状态`（除非是不可中断状态）；关于跟踪状态，个人的理解：【在通过eclipse中设置的断点，程序执行到这里，就会停下来；这时，该进程处于`跟踪状态`】。
- `僵尸状态：`即将结束运行的进程。之所以称为“僵尸状态”，是因为进程的主体信息被删除了，而壳子（退出码、统计信息）未删除。
- `退出状态：`即将结束运行的进程（包含退出码、统计信息也删除）。有两种情况会扭转至该状态：一是、父进程与子进程已被分离，分别处于独立运行；二是、该进程的父进程忽略掉SIGCHLD信号（当一个进程消亡的时候，内核会向其父进程发送SIGCHLD信号）。在这两种情况的下，该进程退出时，是不会扭转至僵尸状态的，而是直接进入退出状态。

> `注意：进程的状态只会在 可运行状态 与 非可运行状态（可中断的睡眠状态、不可中断的睡眠状态、暂停状态、僵尸状态、退出状态） 之间转换。`

**进程的空间** 分为 用户空间 和 内核空间，这两块空间都是操作系统从内存中划分出来的一个范围；可以认为：它们共同瓜分了物理内存 。用户进程 *生存在用户空间中*，*它不能直接访问内核空间*，*不能与硬件交互*；内核可以与计算机硬件交互，但是生存在内核空间。

内存区域中的每一个单元都是有地址的，这些地址可以通过指针来标识和定位。这里的**指针**是一个正整数，由若干个二进制位（二进制位的数量是由计算机CPU的字长决定）表示；也就说，32位机中可以有效标识$2^32$个内存单元，而64位机中可以有效标识$2^64$个内存单元。

> `我们说的32位机、64位机，就是32字长、64字长。字长越大，CPU的运算能力就越牛逼。`

这里所谓的地址，是**虚拟地址**。由虚拟地址标识的内存区域，叫虚拟地址空间（又称**虚拟内存**）。关于用户空间的虚拟内存 与 内核空间的虚拟内存 的分界值（TASK_SIZE），是由计算机体系结构决定的「我的理解 --> 这个值是不变的」。

> `注意：虚拟内存的最大容量与实际可用物理内存的大小无关。`内核与CPU会负责维护虚拟内存与物理内存之间的映射关系。

内核为用户进程分配的是用户空间中的虚拟内存。不同用户进程之间是不可以操作对方的虚拟内存，因为它们各自是独立的，其根本的原因是：它们是被映射到不同的物理内存上。
